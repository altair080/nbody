######################################################################################
####################                    nbody 			  ####################
######################################################################################

nbody is a simple n-body code written in C, parallelized with OpenMP for shared-memory systems and 
utilizing the SDL2 library for graphical output, making it a handy tool to run interactive 
n-body simulations for both scientific and educational purposes.

Author: Marcel VÃ¶lschow, Hamburg Observatory

Current release: 0.4 ALPHA

### Changelog ###
04.01.2017:   	- nbody 0.1 ALPHA released

18.01.2017:   	- VSYNC switch added
              	- Integrator switch added
              	- Object icon (Sun, Mercury, Earth, Jupiter) can be specified
              	- Object icon size can be customized in the init_bodies procedure

20.01.2017:	- RKN5 implemented (stability tests pending)

22.01.2017:	- High CPU load in pause mode bug fixed

23.01.2017:	- Numerical stats output implemented 
		- Code cleanups

24.01.2017:	- RKN5 stability tests completed
		- RKN5 performance optimized
		- Right-click object info box deactivated (buggy)
		- More rigerous truncation error calculation method (minimum fe)
		- Timestep smoothing option added

31.01.2017:	- Minor code cleanups
		- Interactive mode switch implemented
		- Center-of-mass focus added

01.02.2017:	- Minor RKN5 optimizations
		- RKN5 parallelized
		- Number of threads can be specified
		- Code cleanups 
		- examples.c added

06.02.2017:	- New example setups added

09.02.2017:	- Barnes-Hut tree algorithm implementation started
		- RKN6 implemented and parallelized

11.02.2017:	- Benchmark mode added (calls a pre-defined standard setup)

28.01.2018:	- Live view rotation implemented
		- 3D rendering mode added

30.01.2018:	- RKN7 and RKN8 implemented (tests pending)
		- Settings and object configuration files added
		- New sprites added
		- Code and working directory cleanups  

### How to get started ###
Download the repository zip, unpack the archive, open a terminal and type "make".
The GNU C compiler gcc, SDL2 and SDL2_ttf must be present.


### A local SDL2 installation ###
In case you don't have root priviliges on your machine, the SDL2 library can be installed locally to your home directory.

1. Download the SDL2 source code from https://www.libsdl.org/release/SDL2-2.0.7.zip

2. Unzip it in your home directory

3. Open a console and change to the SDL2-2.0.7 directory

4. Run the configure script: ./configure --prefix=$HOME

5. Compile it: make

6. Install it: make install

Repeat the whole procedere for the SDL2_ttf library:

1. Download the SDL2_ttf source code from
https://www.libsdl.org/projects/SDL_ttf/release/SDL2_ttf-2.0.14.zip

2. Unzip it in your home directory

3. Open a console and change to the newly created directory SDL2_ttf-2.0.14

4. Run the configure script: ./configure --prefix=$HOME

5. Compile it: make

6. Install it: make install

You'll find three new folders in your home directory (bin, lib, share) which shouldn't mess up too much.
As a final step, you should add the new library directories to your .bashrc:

1. Open a console in your home directory
2. Type: gedit .bashrc
3. Append the following lines:

export LD_LIBRARY_PATH=$HOME/lib
export PATH="$HOME/bin:$PATH"

4. Save the file, close gedit and close the terminal.


### Running a simulation ###
Simulation settings are specified in the settings.dat file. Kinematic and positional data of the objects are provided
via the input.dat file. Two example setups can be found in the "setups" folder.
Supported physical units (case sensitive) are msun, mjup, pc, au, yrs, Myrs, kms (km per sec.) and ms (m per sec.).
The input.dat file stores kinematic and positional data. The first three lines are reserved for the mass unit, spatial
unit and the velocity unit. The fourth line is reserved for the column headers.
The first column contains the object mass, followed by the x, y and z coordinates, again followed by the vx, vy and vz
velocity components. The eigth column is a sprite index which can be one of the following:
0:	Sun
1:	Mercury
3:	Earth
4:	Mars
5:	Jupiter
8:	Neptune
9:	Pluto
10:	Moon
Sprite size (in pixels) can be defined in the last column.
